#CMPM_146 P2#p2_pathfinder.py# Contributors:# Dustin Halsey - dhalsey# Joshua Husting - jhustingfrom heapq import heappop, heappushimport mathimport time#returns a float of the distance between 2 points#start = (x,y) finish = (x,y)def Find_Euclidean_Distance(start, finish):    x1, y1 = start;    x2, y2 = finish;    return ((x2 - x1)**2 + (y2 - y1)**2)**0.5 # finds the Euclidean distance between the 2 points#find a path across mesh boxes between source_point and destination_pointdef find_path (source_point, destination_point, mesh):    path = [] #will hold the compiled path after running A*. each element formatted as [[x1,y1],[x2,y2]]    boxes = {} #all visited boxes from source    boxesback = {} #all visited boxes from destination    distances = {} #measured distance of best path to that box    distancesback = {} #a separate distances for backwards searching to make sure we dont lose any points    detail_points = {} #the dict of boxes to points where the point is the last point in its best path    sourceBox = (0, 0, 0, 0)    destinationBox = (0, 0, 0, 0)    for box in mesh["boxes"]:        if(source_point[0] >= box[0]) and (source_point[0] <= box[1]) and (source_point[1] >= box[2]) and (source_point[1] <= box[3]):            sourceBox = box        if(destination_point[0] >= box[0]) and (destination_point[0] <= box[1]) and (destination_point[1] >= box[2]) and (destination_point[1] <= box[3]):            destinationBox = box    #Push the starting points onto the heap    frontqueue = [(0, source_point, sourceBox, destination_point), (0, destination_point, destinationBox, source_point)]    distances[sourceBox] = 0    distancesback[destinationBox] = 0    boxes[sourceBox] = -1    boxesback[destinationBox] = -1    detail_points[sourceBox] = source_point    detail_points[destinationBox] = destination_point    midbox = -1 #will hold the box that the forward and backward search meet at    while frontqueue: #continue to search as long as there are valid reachable boxes to search        current_estimation, current_point, current_box, current_goal = heappop(frontqueue)        #if we have found the destination, break        if current_goal == destination_point and current_box in boxesback:            midbox = current_box            break        elif current_goal == source_point and current_box in boxes:            midbox = current_box            break        #used to take the places of source and destination in the algorithm to avoid having an if statement for both directions        distances_current = []        boxes_current = []        if current_goal == destination_point: #if searching source to destination, assign current to use source variables            distances_current = distances            boxes_current = boxes        elif current_goal == source_point: #if searching destination to source, assign current to use destination variables            distances_current = distancesback            boxes_current = boxesback        if current_box not in mesh['adj']:           break        for adjbox in mesh['adj'][current_box]:            xpoints = range( max(current_box[0],adjbox[0]), min(current_box[1],adjbox[1]) + 1 )            ypoints = range( max(current_box[2],adjbox[2]), min(current_box[3],adjbox[3]) + 1 )            minx = -1            miny = -1            minEst = math.inf            for x in xpoints:                for y in ypoints:                                      newEstimation = distances_current[current_box] + Find_Euclidean_Distance(current_point, (x, y)) + Find_Euclidean_Distance((x,y), current_goal)                                       if(newEstimation < minEst):                        minEst = newEstimation                        minx = x                        miny = y            if minx != -1:                if (adjbox not in distances_current) or (minEst < distances_current[adjbox] + Find_Euclidean_Distance((minx,miny), current_goal)):                    boxes_current[adjbox] = current_box                    distances_current[adjbox] = distances_current[current_box] + Find_Euclidean_Distance(current_point, (minx, miny))                    detail_points[adjbox] = (minx, miny)                    heappush(frontqueue, (minEst, (minx, miny), adjbox, current_goal))        #put these values back after every iteration        if current_goal == destination_point:            distances = distances_current            boxes = boxes_current        elif current_goal == source_point:            distancesback = distances_current            boxesback = boxes_current    #If no path is found, print no path    if midbox==-1:         print("No Possible Path Found!")        return path, boxes.keys()    boxIter = midbox    #boxIter = boxesback[midbox] #Josh try this line instead. With only this test, you can see 1-2 lines missing. 1 can drop        #adds the path of the destination midpoint to the destination    while boxIter != -1:        prev = boxesback[boxIter]        if prev != -1: # add new lines until we reach the destination_point            if boxIter == boxesback[prev]:                break            path.insert(0, ([detail_points[boxIter][0],detail_points[boxIter][1]] , [detail_points[prev][0], detail_points[prev][1]])) #prepend        boxIter = boxesback[boxIter]       boxIter = midbox    #boxIter = boxes[midbox] #Josh try this line instead. With only this test, you can see 1 line missing    while boxIter != -1:        prev = boxes[boxIter]        if prev != -1: # add new lines until we reach the souce_point            if boxIter == boxes[prev]:                break            path.insert(len(path)-1, ([detail_points[boxIter][0],detail_points[boxIter][1]] , [detail_points[prev][0], detail_points[prev][1]])) #append            insertpair = ([detail_points[boxIter][0],detail_points[boxIter][1]] , [detail_points[prev][0], detail_points[prev][1]])        boxIter = boxes[boxIter]    boxes.update(boxesback) #combines the two dictionaries of visited boxes from the forward and backwards searches    #Edge case to make sure the line draws properly when the destination is 1 square away.    #otherwise, a line will only be drawn from the source_point to the edge of the destination box, thus    # missing the line from the destination box edge to the destination point    if len(path) == 1:        path.insert(len(path)-1, ([detail_points[midbox][0],detail_points[midbox][1]] , [destination_point[0], destination_point[1]])) #prepend    if len(path) == 0: #if they are in the same box, simply connect them        path.insert(0,([source_point[0],source_point[1]],[destination_point[0],destination_point[1]]))        #in this case, updates the parents of sourceBox and destinationBox because they will be -1 if A* doesnt have to iterate        boxes[sourceBox] = destinationBox        boxes[destinationBox] = sourceBox    return path, boxes.keys()
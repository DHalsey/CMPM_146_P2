from heapq import heappop, heappushimport mathdef Find_Euclidean_Distance(start, finish):    x1, y1 = start;    x2, y2 = finish;    return ((x2 - x1)**2 + (y2 - y1)**2)**0.5 # finds the Euclidean distance between the 2 pointsdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = {} # initially {}    distances = {}    totaldistances = {}    detail_points = {}    sourcebox = (0, 0, 0, 0)    destinationbox = (0, 0, 0, 0)    for box in mesh["boxes"]:        if(source_point[0] >= box[0]) and (source_point[0] <= box[1]) and (source_point[1] >= box[2]) and (source_point[1] <= box[3]):            sourcebox = box        if(destination_point[0] >= box[0]) and (destination_point[0] <= box[1]) and (destination_point[1] >= box[2]) and (destination_point[1] <= box[3]):            destinationbox = box    frontqueue = [(0, sourcebox)]    distances[sourcebox] = 0    totaldistances[sourcebox] = 0    boxes[sourcebox] = -1    detail_points[sourcebox] = source_point    while frontqueue:        current_dist, current_box = heappop(frontqueue)        if current_box == destinationbox:            break        for adjbox in mesh['adj'][current_box]:            xpoints = range( max(current_box[0],adjbox[0]), min(current_box[1],adjbox[1]) + 1 )            ypoints = range( max(current_box[2],adjbox[2]), min(current_box[3],adjbox[3]) + 1 )            minx = -1            miny = -1            minDist = math.inf            for x in xpoints:                for y in ypoints:                    # total to prev + prev to current point + current point to end                    # distances[current_box] + Find_Euc(detail_points[current_box], (x,y)) + find_Euc( (x,y), destination)                    newDistance = distances[current_box] + Find_Euclidean_Distance(detail_points[current_box], (x,y)) + Find_Euclidean_Distance( (x, y), destination_point)                    if newDistance < minDist:                        minDist = newDistance                        minx = x                        miny = y            if minx != -1 and (adjbox not in distances or minDist < distances[adjbox]):                print("xpoints: ", xpoints, "\nypoints: ", ypoints, "\nminx, miny: ", minx, ", ", miny)                detail_points[adjbox] = (minx, miny)                distances[adjbox] = minDist - Find_Euclidean_Distance( (minx, miny), destination_point)                totaldistances[adjbox] = minDist                boxes[adjbox] = current_box                heappush(frontqueue, (minDist, adjbox))    box = boxes[destinationbox]    boxpath = []    path.insert(0, ([destination_point[0], destination_point[1]] , [detail_points[box][0],detail_points[box][1]]))    while box != -1:        prev = boxes[box]        print(detail_points[box])        if(prev != -1):            path.insert(0, ([detail_points[box][0],detail_points[box][1]] , [detail_points[prev][0], detail_points[prev][1]]))        elif(prev == -1):            path.insert(0, ([source_point[0], source_point[1]] , [detail_points[box][0],detail_points[box][1]]))        box = boxes[box]            return path, boxes.keys()
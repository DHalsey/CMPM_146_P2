from heapq import heappop, heappushimport mathimport timedef Find_Euclidean_Distance(start, finish):    x1, y1 = start;    x2, y2 = finish;    return ((x2 - x1)**2 + (y2 - y1)**2)**0.5 # finds the Euclidean distance between the 2 pointsdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = {}    boxesback = {}    distances = {} #measured distance of best path to that box    distancesback = {}    detail_points = {} #the dict of boxes to points where the point is the last point in its best path    sourceBox = (0, 0, 0, 0)    destinationBox = (0, 0, 0, 0)    for box in mesh["boxes"]:        if(source_point[0] >= box[0]) and (source_point[0] <= box[1]) and (source_point[1] >= box[2]) and (source_point[1] <= box[3]):            sourceBox = box        if(destination_point[0] >= box[0]) and (destination_point[0] <= box[1]) and (destination_point[1] >= box[2]) and (destination_point[1] <= box[3]):            destinationBox = box    frontqueue = [(0, source_point, sourceBox, destination_point), (0, destination_point, destinationBox, source_point)]    distances[sourceBox] = 0    distancesback[destinationBox] = 0    boxes[sourceBox] = -1    boxesback[destinationBox] = -1    detail_points[sourceBox] = source_point    detail_points[destinationBox] = destination_point    midbox = -1    while frontqueue:        current_estimation, current_point, current_box, current_goal = heappop(frontqueue)        if current_goal == destination_point and current_box in boxesback:            midbox = current_box            break        elif current_goal == source_point and current_box in boxes:            midbox = current_box            break        distances_current = []        boxes_current = []        if current_goal == destination_point: #if searching source to destination, assign current to use source variables            distances_current = distances            boxes_current = boxes        elif current_goal == source_point: #if searching destination to source, assign current to use destination variables            distances_current = distancesback            boxes_current = boxesback        for adjbox in mesh['adj'][current_box]:            xpoints = range( max(current_box[0],adjbox[0]), min(current_box[1],adjbox[1]) + 1 )            ypoints = range( max(current_box[2],adjbox[2]), min(current_box[3],adjbox[3]) + 1 )            minx = -1            miny = -1            minEst = math.inf            for x in xpoints:                for y in ypoints:                                      newEstimation = distances_current[current_box] + Find_Euclidean_Distance(current_point, (x, y)) + Find_Euclidean_Distance((x,y), current_goal)                                       if(newEstimation < minEst):                        minEst = newEstimation                        minx = x                        miny = y            if minx != -1:                if (adjbox not in distances_current) or (minEst < distances_current[adjbox] + Find_Euclidean_Distance(detail_points[adjbox], current_goal)):                    boxes_current[adjbox] = current_box                    distances_current[adjbox] = distances_current[current_box] + Find_Euclidean_Distance(current_point, (minx, miny))                    detail_points[adjbox] = (minx, miny)                    heappush(frontqueue, (minEst, (minx, miny), adjbox, current_goal))        #put these values back after every iteration        if current_goal == destination_point:            distances = distances_current            boxes = boxes_current        elif current_goal == source_point:            distancesback = distances_current            boxesback = boxes_current    #print(boxes)    #boxIter = boxesback[midbox]    boxIter = midbox    #path.insert(0, ([destination_point[0], destination_point[1]] , [detail_points[boxIter][0],detail_points[boxIter][1]]))    while boxIter != -1: #destination midpoint to destination        prev = boxesback[boxIter]        #print(boxIter)        if prev != -1:            if boxIter == boxesback[prev]:                break            path.insert(0, ([detail_points[boxIter][0],detail_points[boxIter][1]] , [detail_points[prev][0], detail_points[prev][1]])) #prepend        #elif(prev == -1):        #    path.insert(0, ([source_point[0], source_point[1]] , [detail_points[boxIter][0],detail_points[boxIter][1]])) #prepend        boxIter = boxesback[boxIter]       #boxIter = boxes[midbox]    boxIter = midbox    while boxIter != -1: #source midpoint to source        prev = boxes[boxIter]        if prev != -1:            if boxIter == boxes[prev]:                break            path.insert(len(path)-1, ([detail_points[boxIter][0],detail_points[boxIter][1]] , [detail_points[prev][0], detail_points[prev][1]])) #append            insertpair = ([detail_points[boxIter][0],detail_points[boxIter][1]] , [detail_points[prev][0], detail_points[prev][1]])        #elif(prev == -1):        #    path.insert(0, ([source_point[0], source_point[1]] , [detail_points[boxIter][0],detail_points[boxIter][1]])) #append        #print("Inserted pair: ", insertpair, "\nSource: ", source_point, "\nprev: ", prev, "\nboxIter: ", boxIter)        boxIter = boxes[boxIter]    boxes.update(boxesback)    return path, boxes.keys()